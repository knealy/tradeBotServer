{
  "version": "1.3.0",
  "last_updated": "2025-12-04",
  "description": "Context profile for common problems, fixes, and patterns in the tradeBotServer codebase",
  
  "common_problems": {
    "jwt_token_expiration": {
      "problem": "JWT tokens expire causing 500 errors on API calls, especially /api/Order/place",
      "symptoms": [
        "500 Internal Server Error on order placement",
        "Max retries exceeded with url: /api/Order/place",
        "ResponseError('too many 500 error responses')",
        "Orders fail to place even when credentials are valid"
      ],
      "root_causes": [
        "Token expires after ~30 minutes but code doesn't auto-refresh",
        "Using expired token in Authorization header",
        "No retry logic with token refresh on 500 errors",
        "Calling authenticate() directly instead of _ensure_valid_token()"
      ],
      "solutions": [
        {
          "file": "trading_bot.py",
          "method": "place_oco_bracket_with_stop_entry",
          "fix": "Add automatic token refresh and retry on 500 errors",
          "code_pattern": "if 'error' in response and '500' in str(response.get('error', '')): await self._ensure_valid_token(); await asyncio.sleep(0.75); retry request"
        },
        {
          "file": "trading_bot.py",
          "method": "_make_curl_request",
          "fix": "Remove None values from JSON payloads (TopStepX rejects None)",
          "code_pattern": "cleaned_data = {k: v for k, v in data.items() if v is not None}"
        },
        {
          "file": "servers/async_webhook_server.py",
          "fix": "Use _ensure_valid_token() instead of authenticate() on startup",
          "code_pattern": "await trading_bot._ensure_valid_token()  # Not authenticate()"
        }
      ],
      "prevention": [
        "Always use _ensure_valid_token() instead of authenticate() directly",
        "Check token expiration before making API calls",
        "Implement retry logic with token refresh on 500 errors",
        "Add 0.75s delay before retry to prevent rate limiting",
        "Log JSON payloads for debugging order placement issues"
      ],
      "related_files": [
        "trading_bot.py",
        "servers/async_webhook_server.py",
        "docs/JWT_AUTO_REFRESH_FIX_2025-12-02.md"
      ]
    },
    
    "async_await_syntax_errors": {
      "problem": "Using await in synchronous functions causes SyntaxError",
      "symptoms": [
        "SyntaxError: 'await' outside async function",
        "Line numbers pointing to await statements in sync methods"
      ],
      "root_causes": [
        "Adding await to synchronous methods like _make_curl_request()",
        "Forgetting to make function async when adding await",
        "Mixing sync and async code incorrectly"
      ],
      "solutions": [
        {
          "pattern": "If method is sync, handle async operations in caller",
          "example": "_make_curl_request() is sync, token refresh happens in async caller"
        },
        {
          "pattern": "Make function async if it needs await",
          "example": "async def place_oco_bracket_with_stop_entry(...)"
        }
      ],
      "prevention": [
        "Check function signature before adding await",
        "If function is 'def', it's sync - handle async in caller",
        "If function is 'async def', it can use await",
        "Clear Python cache files if syntax errors persist: find . -name '*.pyc' -delete"
      ]
    },
    
    "account_tracker_missing_methods": {
      "problem": "AccountTracker missing get_daily_pnl() method causing strategy failures",
      "symptoms": [
        "'AccountTracker' object has no attribute 'get_daily_pnl'",
        "Strategies fail to analyze: Error analyzing MNQ/MES",
        "No trade signals generated"
      ],
      "root_causes": [
        "Strategy code calls tracker.get_daily_pnl() but method doesn't exist",
        "Missing properties: current_balance, daily_loss_limit, etc."
      ],
      "solutions": [
        {
          "file": "core/account_tracker.py",
          "fix": "Add get_daily_pnl() method and required properties",
          "methods_added": [
            "get_daily_pnl(account_id=None) -> float",
            "property current_balance -> float",
            "property daily_loss_limit -> float",
            "property highest_EOD_balance -> float",
            "property maximum_loss_limit -> float"
          ]
        }
      ],
      "prevention": [
        "Ensure AccountTracker implements all methods used by strategies",
        "Check strategy_base.py for required tracker methods",
        "Add properties for commonly accessed state values"
      ]
    },
    
    "signalr_connection_spam": {
      "problem": "SignalR connection spam causing thousands of failed connection attempts",
      "symptoms": [
        "Massive log spam (30,000+ logs/minute)",
        "Continuous 403 Forbidden errors",
        "Railway rate limit hit (500 logs/sec)",
        "High CPU usage from failed reconnections"
      ],
      "root_causes": [
        "reconnect_interval: 1 (retry every 1 second)",
        "max_attempts: 0 (unlimited retries)",
        "No exponential backoff",
        "No special handling for 403 errors"
      ],
      "solutions": [
        {
          "file": "trading_bot.py",
          "fix": "Implement exponential backoff and limit retries",
          "changes": {
            "reconnect_interval": "5 (was 1)",
            "max_attempts": "10 (was 0/unlimited)",
            "keep_alive_interval": "15 (was 10)"
          }
        },
        {
          "fix": "Add 403 error detection to reduce log spam",
          "code_pattern": "if '403' in error_text: logger.error('...'); return"
        }
      ],
      "prevention": [
        "Always set max_attempts for reconnection logic",
        "Use exponential backoff for retries",
        "Detect and handle specific error codes (403, 401) specially",
        "Don't log the same error repeatedly"
      ]
    },
    "signalr_401_authentication_error": {
      "problem": "SignalR WebSocket connections failing with 401 Unauthorized errors",
      "symptoms": [
        "WebSocketBadStatusException: Handshake status 401 Unauthorized",
        "SignalR Market Hub disconnected immediately after connection attempt",
        "Connection timeout after 10 seconds",
        "Real-time market data not available"
      ],
      "root_causes": [
        "Token expired when SignalR tries to connect",
        "Token not refreshed before connection attempt",
        "access_token_factory using stale token (captured at connection time)",
        "No token refresh on 401 errors"
      ],
      "solutions": [
        {
          "file": "core/websocket_manager.py",
          "method": "start()",
          "fix": "Ensure token is valid before connecting - call ensure_valid_token() first",
          "code_pattern": "await self.auth_manager.ensure_valid_token()  # BEFORE getting token"
        },
        {
          "file": "core/websocket_manager.py",
          "method": "start()",
          "fix": "Use fresh token factory that always gets latest token",
          "code_pattern": "def get_fresh_token(): return self.auth_manager.get_token() or \"\""
        },
        {
          "file": "core/websocket_manager.py",
          "method": "on_error()",
          "fix": "Handle 401 errors by refreshing token and reconnecting",
          "code_pattern": "if '401' in error_text: asyncio.create_task(self._handle_auth_error_and_reconnect())"
        },
        {
          "file": "core/websocket_manager.py",
          "method": "_handle_auth_error_and_reconnect()",
          "fix": "New method to refresh token, stop connection, wait, and reconnect",
          "details": "Stops current hub, refreshes token, waits 1s, then calls start() again"
        }
      ],
      "prevention": [
        "Always call ensure_valid_token() before getting token for SignalR",
        "Use token factory function instead of capturing token value",
        "Handle 401 errors with automatic token refresh and reconnection",
        "Don't suppress 401 errors - fix the root cause (expired token)",
        "Test SignalR connection with token that's about to expire"
      ],
      "related_files": [
        "core/websocket_manager.py",
        "core/auth.py"
      ]
    },
    
    "strategy_status_keyerror": {
      "problem": "strategies status command fails with KeyError: 'status'",
      "symptoms": [
        "KeyError: 'status' when running 'strategies status'",
        "Strategy status display fails"
      ],
      "root_causes": [
        "OvernightRangeStrategy.get_status() overrides base method without calling super()",
        "Missing required fields from base class"
      ],
      "solutions": [
        {
          "file": "strategies/overnight_range_strategy.py",
          "fix": "Call super().get_status() first, then add custom fields",
          "code_pattern": "status = super().get_status(); status.update({...custom fields...})"
        }
      ],
      "prevention": [
        "Always call super() when overriding methods",
        "Include all required fields from base class",
        "Test CLI commands after strategy changes"
      ]
    },
    
    "excessive_api_calls": {
      "problem": "Frontend polling too frequently causing slow dashboard",
      "symptoms": [
        "Dashboard slow to load",
        "Multiple API calls for same data",
        "Slow API warnings (5+ seconds)",
        "High API usage"
      ],
      "solutions": [
        {
          "area": "Frontend polling intervals",
          "changes": {
            "accounts": "30s ‚Üí 60s",
            "account_info": "5s ‚Üí 15s",
            "metrics": "10s ‚Üí 30s",
            "positions": "5s ‚Üí 10s"
          }
        },
        {
          "area": "Backend optimization",
          "fix": "Use balances from list_accounts() instead of individual calls",
          "fix": "Add React Query staleTime for better caching"
        }
      ],
      "prevention": [
        "Use appropriate polling intervals (not too frequent)",
        "Leverage React Query caching",
        "Use WebSocket for real-time updates when possible",
        "Cache API responses on backend"
      ]
    },
    
    "chart_realtime_updates": {
      "problem": "Chart bars not updating in real-time",
      "symptoms": [
        "Only 2m timeframe shows recent data",
        "Other timeframes lag 20-30 minutes",
        "Bars generated once and never updated"
      ],
      "root_causes": [
        "Bar aggregator only supports limited timeframes",
        "Frontend too strict about timeframe matching",
        "Bar aggregator not initializing all requested timeframes"
      ],
      "solutions": [
        {
          "file": "core/bar_aggregator.py",
          "fix": "Expand default timeframes to include all chart timeframes"
        },
        {
          "file": "frontend/src/components/TradingChart.tsx",
          "fix": "Relax timeframe matching in WebSocket updates",
          "fix": "Add timeframe subscription request"
        }
      ],
      "prevention": [
        "Initialize all timeframes when symbol is registered",
        "Don't be too strict about timeframe matching",
        "Subscribe to timeframe-specific updates"
      ]
    },
    
    "excessive_logging_verbosity": {
      "problem": "Terminal output is too verbose with INFO-level logs cluttering the console",
      "symptoms": [
        "Terminal flooded with 'Fetching historical data' messages",
        "INFO logs appearing in console during normal operation",
        "Difficult to see important warnings/errors",
        "User wants cleaner terminal output"
      ],
      "root_causes": [
        "Both file and console handlers set to same log level (INFO)",
        "No separation between file logging and console output",
        "All INFO logs go to both file and console"
      ],
      "solutions": [
        {
          "file": "trading_bot.py",
          "section": "Logging configuration (lines 66-91)",
          "fix": "Set console_handler to WARNING level, keep file_handler at INFO level",
          "code_pattern": "console_handler.setLevel(logging.WARNING)  # Only WARNING+ in terminal\nfile_handler.setLevel(getattr(logging, log_level, logging.INFO))  # All logs to file"
        },
        {
          "file": "trading_bot.py",
          "section": "main() function",
          "fix": "Add startup message indicating logs go to file",
          "code_pattern": "print('‚ÑπÔ∏è  Detailed logs are being written to: trading_bot.log')\nprint('   (Terminal will only show warnings and errors)')"
        }
      ],
      "prevention": [
        "Always separate file and console log levels",
        "File handler should capture all logs (INFO+)",
        "Console handler should only show important messages (WARNING+)",
        "Add startup message to inform users where logs are written",
        "Keep verbose flag to enable full console logging when needed"
      ],
      "related_files": [
        "trading_bot.py"
      ]
    }
  },
  
  "syntax_linter_errors": {
    "datetime_utcnow_deprecation": {
      "error": "DeprecationWarning: datetime.datetime.utcnow() is deprecated",
      "common_locations": [
        "trading_bot.py",
        "core/discord_notifier.py",
        "docs/DATABASE_ARCHITECTURE.md"
      ],
      "fix": "Replace datetime.utcnow() with datetime.now(timezone.utc)",
      "code_pattern": "from datetime import datetime, timezone\n# Replace:\ndatetime.utcnow()\n# With:\ndatetime.now(timezone.utc)",
      "prevention": "Always use timezone-aware datetime objects. Import timezone from datetime module.",
      "related_files": [
        "trading_bot.py",
        "core/discord_notifier.py"
      ]
    },
    "datetime_timezone_mismatch": {
      "error": "TypeError: can't subtract offset-naive and offset-aware datetimes",
      "common_locations": [
        "trading_bot.py _eod_scheduler()",
        "Any datetime arithmetic operations"
      ],
      "symptoms": [
        "Error when subtracting two datetime objects",
        "One datetime is timezone-aware, the other is timezone-naive"
      ],
      "root_causes": [
        "datetime.combine() creates timezone-naive datetime by default",
        "Mixing datetime.now(timezone.utc) with datetime.combine() without tzinfo",
        "Using datetime.utcnow() (naive) with datetime.now(timezone.utc) (aware)"
      ],
      "fix": "Ensure both datetimes are timezone-aware when performing arithmetic",
      "code_pattern": "# Wrong:\nnow = datetime.now(timezone.utc)  # aware\nmidnight = datetime.combine(date, time.min)  # naive\nresult = midnight - now  # ERROR!\n\n# Correct:\nnow = datetime.now(timezone.utc)  # aware\nmidnight = datetime.combine(date, time.min, tzinfo=timezone.utc)  # aware\nresult = midnight - now  # OK!",
      "prevention": [
        "Always specify tzinfo when using datetime.combine()",
        "Use datetime.now(timezone.utc) instead of datetime.utcnow()",
        "Ensure all datetime objects in arithmetic operations have the same timezone awareness",
        "Use timezone.utc for UTC operations"
      ],
      "related_files": [
        "trading_bot.py"
      ]
    },
    "await_outside_async": {
      "error": "SyntaxError: 'await' outside async function",
      "common_locations": [
        "trading_bot.py line 753 (if added to sync method)",
        "Any sync method (_make_curl_request, etc.)"
      ],
      "fix": "Move await to async caller or make function async",
      "prevention": "Check function signature before adding await"
    },
    "missing_imports": {
      "error": "NameError: name 'X' is not defined",
      "common_causes": [
        "Missing import statements",
        "Circular imports",
        "Import order issues"
      ],
      "fix": "Add proper imports at top of file",
      "prevention": "Use linter to catch missing imports"
    },
    "type_errors": {
      "error": "TypeError: 'X' object is not callable",
      "common_causes": [
        "Passing coroutine object instead of callable",
        "Missing parentheses on function call",
        "Variable shadowing function name"
      ],
      "fix": "Ensure functions are callable, not coroutine objects",
      "prevention": "Use proper async/await patterns"
    },
    "attribute_errors": {
      "error": "AttributeError: 'X' object has no attribute 'Y'",
      "common_causes": [
        "Missing method implementation",
        "Wrong object type",
        "Method renamed but not updated everywhere"
      ],
      "fix": "Add missing method or fix object type",
      "prevention": "Use type hints and check object interfaces"
    },
    "key_errors": {
      "error": "KeyError: 'X'",
      "common_causes": [
        "Missing key in dictionary",
        "Overriding method without including all keys",
        "API response structure changed"
      ],
      "fix": "Check dictionary keys before access, use .get() with defaults",
      "prevention": "Always call super() when overriding, validate API responses"
    }
  },
  
  "code_patterns": {
    "avoid": [
      "Calling authenticate() directly - use _ensure_valid_token() instead",
      "Adding await to synchronous methods",
      "Including None values in JSON payloads to TopStepX API",
      "Unlimited retry loops (max_attempts: 0)",
      "Retry intervals < 1 second without backoff",
      "Overriding methods without calling super()",
      "Polling too frequently (< 5 seconds)",
      "Logging the same error repeatedly"
    ],
    "prefer": [
      "Use _ensure_valid_token() for token management",
      "Handle async operations in async callers",
      "Remove None values from JSON before sending",
      "Implement exponential backoff for retries",
      "Set reasonable max_attempts limits",
      "Call super() when overriding methods",
      "Use appropriate polling intervals (15s+)",
      "Detect and handle specific error codes specially",
      "Log JSON payloads for debugging order issues",
      "Add 0.75s delay before retrying failed requests"
    ]
  },
  
  "best_practices": {
    "token_management": [
      "Always use _ensure_valid_token() instead of authenticate()",
      "Check token expiration before API calls",
      "Implement automatic refresh on 500 errors",
      "Add retry delay (0.75s) to prevent rate limiting",
      "Log token status for debugging"
    ],
    "async_programming": [
      "Check function signature (def vs async def) before adding await",
      "Handle async operations in async callers",
      "Use asyncio.sleep() for delays in async code",
      "Clear Python cache if syntax errors persist"
    ],
    "error_handling": [
      "Detect specific error codes (403, 401, 500) and handle specially",
      "Don't log the same error repeatedly",
      "Implement exponential backoff for retries",
      "Set reasonable max_attempts limits",
      "Log request payloads for debugging"
    ],
    "api_integration": [
      "Remove None values from JSON payloads",
      "Validate required fields before sending",
      "Round prices to tick size before sending",
      "Log JSON payloads for debugging",
      "Handle 500 errors with token refresh and retry"
    ],
    "strategy_development": [
      "Always call super() when overriding methods",
      "Include all required fields from base class",
      "Ensure AccountTracker implements all required methods",
      "Test CLI commands after changes"
    ]
  },
  
  "file_specific_notes": {
    "trading_bot.py": {
      "critical_methods": [
        "_make_curl_request() - SYNC method, no await allowed",
        "_ensure_valid_token() - ASYNC method, use for token management",
        "place_oco_bracket_with_stop_entry() - ASYNC, handles token refresh on 500 errors",
        "_get_contract_id() - Raises ValueError if contracts not available (no hardcoded fallbacks)",
        "_eod_scheduler() - Uses timezone-aware datetimes (datetime.now(timezone.utc))"
      ],
      "common_issues": [
        "Don't add await to _make_curl_request()",
        "Use _ensure_valid_token() not authenticate()",
        "Remove None from JSON payloads before sending",
        "Contracts must be fetched before use - no hardcoded fallbacks",
        "Always use timezone-aware datetimes for arithmetic operations"
      ],
      "migration_notes": {
        "rust_migration_priority": "High - 9,568 lines, needs refactoring before migration",
        "hot_paths_for_rust": [
          "place_market_order() - Order execution",
          "modify_order() - Order modification",
          "get_historical_data() - Data aggregation",
          "WebSocket message processing",
          "Strategy execution framework"
        ],
        "keep_in_python": [
          "Strategy implementations (easy to modify)",
          "CLI interface (user interaction)",
          "Configuration management"
        ]
      }
    },
    "core/account_tracker.py": {
      "required_methods": [
        "get_daily_pnl(account_id=None)",
        "property current_balance",
        "property daily_loss_limit",
        "property highest_EOD_balance",
        "property maximum_loss_limit"
      ],
      "used_by": [
        "strategies/strategy_base.py - _check_dll_compliance()",
        "strategies/strategy_base.py - _check_mll_compliance()"
      ]
    },
    "servers/async_webhook_server.py": {
      "startup_pattern": "Use _ensure_valid_token() not authenticate()",
      "common_issues": [
        "Token refresh on startup",
        "CORS configuration",
        "Route registration"
      ]
    }
  },
  
  "debugging_tips": {
    "syntax_errors": [
      "Clear Python cache: find . -name '*.pyc' -delete",
      "Check function signature (def vs async def)",
      "Verify await is only in async functions",
      "Check for missing imports"
    ],
    "api_errors": [
      "Log JSON payloads before sending",
      "Check token expiration",
      "Verify None values removed from payload",
      "Check for 500 errors and implement token refresh",
      "Add retry delay to prevent rate limiting"
    ],
    "strategy_errors": [
      "Check AccountTracker has required methods",
      "Verify super() is called when overriding",
      "Check all required fields are included",
      "Test CLI commands after changes"
    ]
  },
  
  "recent_fixes": [
    {
      "date": "2025-12-04",
      "issue": "JWT token expiration causing 500 errors on order placement",
      "fix": "Added automatic token refresh and retry on 500 errors in place_oco_bracket_with_stop_entry()",
      "files": ["trading_bot.py"]
    },
    {
      "date": "2025-12-04",
      "issue": "AccountTracker missing get_daily_pnl() method",
      "fix": "Added get_daily_pnl() and required properties to AccountTracker",
      "files": ["core/account_tracker.py"]
    },
    {
      "date": "2025-12-04",
      "issue": "None values in JSON payloads causing API rejections",
      "fix": "Remove None values from JSON before sending to TopStepX API",
      "files": ["trading_bot.py"]
    },
    {
      "date": "2025-12-04",
      "issue": "Excessive logging verbosity in terminal",
      "fix": "Set console handler to WARNING level, keep file handler at INFO level. Added startup message indicating logs go to file.",
      "files": ["trading_bot.py"]
    },
    {
      "date": "2025-12-04",
      "issue": "datetime.utcnow() deprecation warnings",
      "fix": "Replaced all datetime.utcnow() calls with datetime.now(timezone.utc). Updated imports to include timezone from datetime module.",
      "files": ["trading_bot.py", "core/discord_notifier.py", "docs/DATABASE_ARCHITECTURE.md"]
    },
    {
      "date": "2025-12-04",
      "issue": "EOD scheduler error: can't subtract offset-naive and offset-aware datetimes",
      "fix": "Fixed datetime.combine() to include tzinfo=timezone.utc in _eod_scheduler(). Added timezone to local imports.",
      "files": ["trading_bot.py"]
    },
    {
      "date": "2025-12-04",
      "issue": "SignalR depth subscription errors: Method does not exist (SubscribeOrderBook, SubscribeLevel2)",
      "fix": "Updated _ensure_depth_subscription() to try SubscribeContractDepth first (following SubscribeContractQuotes pattern), suppress expected 'method does not exist' errors, and gracefully fall back to REST API. Changed error logging to debug level for expected failures.",
      "files": ["trading_bot.py"]
    },
    {
      "date": "2025-12-04",
      "issue": "Hardcoded contract fallbacks causing expired contract issues",
      "fix": "Removed all hardcoded contract mappings. Implemented dynamic contract fetching with automatic selection of most recent/active contract with highest volume. Enhanced symbol extraction from contract IDs and improved error messages.",
      "files": ["trading_bot.py"],
      "impact": "Critical - Prevents using expired contracts, ensures always using active contracts"
    },
    {
      "date": "2025-12-04",
      "issue": "Database missing record_notification method",
      "fix": "Added notifications table to PostgreSQL schema and record_notification() method to DatabaseManager. Supports account_id, notification_type, message, level, and optional metadata.",
      "files": ["infrastructure/database.py"]
    },
    {
      "date": "2025-12-04",
      "issue": "No comprehensive test suite for all commands",
      "fix": "Created tests/test_all_commands.py - comprehensive test suite that tests all 12+ commands, measures execution times, generates performance reports, and exports JSON results. Achieved 100% success rate on all commands.",
      "files": ["tests/test_all_commands.py", "tests/README_TEST_ALL_COMMANDS.md"],
      "impact": "Critical for Rust migration - establishes performance baselines"
    },
    {
      "date": "2025-12-04",
      "issue": "trading_bot.py is 9,769 lines - needs refactoring for Rust migration",
      "fix": "üéâ CRITICAL PATH COMPLETE! Systematic refactoring achieved major milestone: All 13 critical path methods implemented in TopStepXAdapter. Created translation layer interfaces, event bus system, extracted RateLimiter, completed AuthManager, created ContractManager, OrderExecutor. Implemented: Order methods (5/5: place_market_order, modify_order, cancel_order, get_open_orders, get_order_history), Position methods (4/4: get_positions, get_position_details, close_position, flatten_all_positions), Market Data methods (4/4: get_historical_data, get_market_quote, get_market_depth, get_available_contracts). All methods include full TopStepX API integration, token refresh on 500 errors, proper error handling, and response conversion. Created comprehensive method mapping plan (METHOD_MAPPING_PLAN.md) for all 100+ methods. All modules tested and working.",
      "files": [
        "core/interfaces/",
        "events/",
        "core/rate_limiter.py",
        "core/auth.py",
        "core/market_data.py",
        "core/order_execution.py",
        "brokers/topstepx_adapter.py",
        "tests/test_auth_manager.py",
        "docs/METHOD_MAPPING_PLAN.md",
        "docs/REFACTORING_STATUS.md"
      ],
      "impact": "CRITICAL MILESTONE - All critical path methods complete! Foundation for modular architecture and Rust migration is solid. TopStepXAdapter is now fully functional for all core trading operations. Ready for integration into main trading_bot.py with dependency injection."
    },
    {
      "date": "2025-12-04",
      "issue": "Integration Steps 1-5: Complete modular architecture integration",
      "fix": "‚úÖ ALL INTEGRATION STEPS COMPLETE! Step 1: Integrated TopStepXAdapter into trading_bot.py with dependency injection. Step 2: Implemented advanced order methods (place_oco_bracket_with_stop_entry, place_trailing_stop_order, create_bracket_order) - stop bracket orders are the most critical order type. Step 3: Extracted remaining modules - created RiskManager (tick sizes, point values, trading sessions), PositionManager (modify_stop_loss, modify_take_profit), integrated both into trading_bot.py with backward compatibility wrappers. Step 4: Created WebSocketManager for SignalR real-time data - handles connection lifecycle, subscriptions, and event callbacks. Integrated into trading_bot.py with callbacks for quote/depth updates. Step 5: Historical data caching already enhanced - 3-tier cache (memory, Parquet/Pickle, PostgreSQL), aggregation support (1m bars ‚Üí higher timeframes), dynamic TTL based on market hours. All methods maintain backward compatibility. Code compiles without errors.",
      "files": [
        "core/risk_management.py",
        "core/position_management.py",
        "core/websocket_manager.py",
        "trading_bot.py",
        "docs/METHOD_MAPPING_PLAN.md",
        "docs/REFACTORING_GUIDE.md"
      ],
      "impact": "MAJOR MILESTONE - Complete modular architecture! All core modules extracted and integrated. System is now highly modular, maintainable, and ready for Rust migration. Backward compatibility maintained throughout."
    },
    {
      "date": "2025-12-04",
      "issue": "SignalR 401 Unauthorized errors - WebSocket connections failing due to expired tokens",
      "fix": "‚úÖ FIXED ROOT CAUSE! Implemented proper token refresh before SignalR connection: (1) Call ensure_valid_token() BEFORE getting token for connection, (2) Use fresh token factory function instead of capturing token value, (3) Handle 401 errors with automatic token refresh and reconnection via _handle_auth_error_and_reconnect(), (4) Removed error suppression - now properly fixing the issue instead of hiding it. This ensures SignalR always uses fresh, valid tokens and automatically recovers from auth errors.",
      "files": [
        "core/websocket_manager.py",
        "trading_bot.py"
      ],
      "impact": "CRITICAL FIX - SignalR connections now work reliably with proper token management. Real-time market data will be available without 401 errors. Foundation for high-performance system is solid - problems are fixed, not suppressed."
    },
    {
      "date": "2025-12-04",
      "issue": "RuntimeWarning: coroutine 'WebSocketManager._flush_pending_subscriptions' was never awaited - async function called from sync SignalR callback",
      "fix": "‚úÖ FIXED! SignalR callbacks (on_open, on_close, on_error) are synchronous, but _flush_pending_subscriptions() is async. Fixed by: (1) Store event loop reference in start() method, (2) Check if event loop is running before creating task, (3) If no running loop, run async function in separate thread with new event loop. This properly handles async operations from synchronous SignalR callbacks without warnings.",
      "files": [
        "core/websocket_manager.py"
      ],
      "impact": "Eliminates runtime warnings and ensures pending subscriptions are properly flushed when SignalR connects. Proper async/sync boundary handling for high-performance system."
    },
    {
      "date": "2025-12-04",
      "issue": "Rust migration Phase 1: PyO3 async return type conversion blocking compilation",
      "fix": "‚ö†Ô∏è IN PROGRESS - Rust order execution module 90% complete. Full place_market_order implementation with HTTP client, token management, contract caching, bracket orders, error handling. BLOCKER: pyo3-asyncio expects PyResult<Py<PyAny>> but PyObject (type alias for Py<PyAny>) conversion not working. Tried: .into(), Py::from(), type assertions. Need to research pyo3-asyncio 0.20 correct pattern or use alternative approach.",
      "files": [
        "rust/src/order_execution/mod.rs",
        "rust/Cargo.toml",
        "docs/RUST_IMPLEMENTATION_STATUS.md"
      ],
      "impact": "Rust infrastructure 90% complete. Once compilation blocker resolved, can proceed with modify/cancel methods, integration tests, and performance benchmarks. Foundation is solid."
    }
  ],
  
  "migration_readiness": {
    "current_phase": "Phase 1 (Rust Infrastructure) - 90% Complete, Compilation Blocker",
    "baseline_metrics_established": true,
    "test_suite_ready": true,
    "performance_targets": {
      "order_execution": "< 5ms (currently 100-150ms)",
      "order_modification": "< 3ms (currently 30-50ms)",
      "websocket_processing": "< 1ms (currently 5-10ms)",
      "data_aggregation": "10x faster (currently ~500ms)",
      "strategy_execution": "< 10ms (currently 50-100ms)"
    },
    "migration_priorities": [
      {
        "priority": 1,
        "component": "Order Execution Engine",
        "target_file": "rust/src/order_execution/mod.rs",
        "current_file": "trading_bot.py::place_market_order",
        "expected_gain": "20-30x faster"
      },
      {
        "priority": 2,
        "component": "WebSocket Processing",
        "target_file": "rust/src/websocket/mod.rs",
        "current_file": "servers/websocket_server.py",
        "expected_gain": "5-10x faster"
      },
      {
        "priority": 3,
        "component": "Market Data Aggregation",
        "target_file": "rust/src/market_data/aggregation.rs",
        "current_file": "trading_bot.py::get_historical_data",
        "expected_gain": "10x faster"
      },
      {
        "priority": 4,
        "component": "Strategy Engine",
        "target_file": "rust/src/strategy_engine/mod.rs",
        "current_file": "strategies/strategy_base.py",
        "expected_gain": "5-10x faster"
      },
      {
        "priority": 5,
        "component": "Database Operations",
        "target_file": "rust/src/database/mod.rs",
        "current_file": "infrastructure/database.py",
        "expected_gain": "2.5x faster"
      }
    ],
    "pre_migration_tasks": [
      {
        "task": "Code refactoring - split trading_bot.py",
        "status": "in_progress",
        "priority": "high",
        "details": "‚úÖ Core modules extracted: RiskManager, PositionManager, WebSocketManager, AuthManager, ContractManager, TopStepXAdapter. ‚úÖ Advanced order methods complete. ‚úÖ Integration with dependency injection complete. Remaining: Extract order execution orchestration, enhance historical data caching (already has 3-tier cache)."
      },
      {
        "task": "Set up Rust project structure",
        "status": "completed",
        "priority": "high",
        "details": "‚úÖ Created rust/ directory with Cargo.toml, src/ structure (order_execution, market_data, websocket, strategy_engine, database), tests/, benches/. All dependencies configured (pyo3, pyo3-asyncio, tokio, reqwest, serde, etc.)"
      },
      {
        "task": "Python-Rust interop setup",
        "status": "in_progress",
        "priority": "high",
        "details": "‚ö†Ô∏è PyO3 and pyo3-asyncio configured. Order execution module 90% complete with full place_market_order implementation. BLOCKER: PyO3 async return type conversion issue (PyObject to Py<PyAny>) preventing compilation. See docs/RUST_IMPLEMENTATION_STATUS.md for details."
      },
      {
        "task": "Documentation cleanup",
        "status": "pending",
        "priority": "medium",
        "details": "Consolidate duplicate docs, update outdated information, create migration guides"
      }
    ],
    "hybrid_architecture_decision": {
      "approach": "Keep Python for strategies, migrate hot paths to Rust",
      "rationale": [
        "Strategies easier to modify in Python",
        "Hot paths benefit from Rust performance",
        "Gradual migration reduces risk",
        "Best of both worlds"
      ],
      "keep_in_python": [
        "Strategy implementations",
        "CLI interface",
        "Configuration management",
        "High-level orchestration"
      ],
      "migrate_to_rust": [
        "Order execution",
        "WebSocket processing",
        "Market data aggregation",
        "Database hot paths",
        "Strategy execution framework"
      ]
    }
  }
}

